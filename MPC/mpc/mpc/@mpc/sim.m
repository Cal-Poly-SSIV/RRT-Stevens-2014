function varargout = sim(MPCobj, varargin)
%SIM Closed-loop MPC simulation
%
%   SIM(MPCobj,T,r) simulates the closed-loop system formed by the plant
%   model specified in MPCobj.Model.Plant and by the MPC controller
%   specified by the MPC object MPCobj, and plots the simulation results.
%   T is the number of simulation steps. r is the reference signal array
%   with as many columns as the number of output variables.
%
%   SIM(MPCobj,T,r,v) also specified the measured disturbance signal v,
%   which has as many columns as the number of measured disturbances.
%
%   The last sample of r/v is extended constantly over the simulation horizon,
%   to obtain the correct size.
%
%   SIM(MPCobj,T,r,SimOptions) or SIM(MPCobj,T,r,v,SimOptions)
%   specifies the simulation options object SimOptions, such as
%   initial states, input/output noise and unmeasured disturbances,
%   plant mismatch, etc. Type HELP MPCSIMOPT for details.
%
%   [y,t,u,xp,xmpc,SimOptions]=SIM(MPCobj,T,r,v) instead of plotting 
%   closed-loop trajectories returns the following output arguments:
%            y: sequence of plant outputs
%            t: time sequence (equally spaced by MPCobj.Ts)
%            u: sequence of manipulated variables generated by the MPC controller
%           xp: sequence of states of Plant model (from Model / simModel)
%         xmpc: sequence of states of MPC controller (extended state observer)
%   SimOptions: MPC simulation options used (type HELP MPCSIMOPT for details)
%
%   See also MPCSIMOPT, MPCSIMSET, MPCSIMGET, MPCMOVE.

%   Author: A. Bemporad
%   Copyright 1986-2007 The MathWorks, Inc.
%   $Revision: 1.1.10.9 $  $Date: 2007/11/09 20:39:51 $

narg = nargin;
error(nargchk(1,5,narg));

verbose = mpccheckverbose;

if isempty(MPCobj),
    ctrlMsgUtils.error('MPC:general:EmptyMPCObject','sim');
end

InitFlag=MPCobj.MPCData.Init;
save_flag='mpcloop';

if ~isfield(MPCobj.MPCData,'MPCstruct'),
    InitFlag=0;
else
    if ~isfield(MPCobj.MPCData.MPCstruct,'Bup'),
        InitFlag=0;
    end
end

if ~InitFlag,
    % Initialize MPC object (QP matrices and observer)
    try
        MPCstruct=mpc_struct(MPCobj,[],save_flag); %x0,u0 are not checked by MPC_CHKX0U1
    catch ME
        throw(ME);
    end
    MPCobj = mpc_updatempcdata(MPCobj,MPCstruct,1,1,1);        
    % Before invoking SS, update object (init, ready) when necessary   
    if ~isempty(inputname(1))
        assignin('caller',inputname(1),MPCobj);
    end
else
    MPCstruct=MPCobj.MPCData.MPCstruct;
end

% Retrieves parameters from MPCstruct
ny=MPCstruct.ny;
nv=MPCstruct.nv;
nym=MPCstruct.nym;
nu=MPCstruct.nu;
nd=length(MPCobj.MPCData.unindex);
% Note: nd here equals the number of UMDs to Plant, while MPCstruct.nd denotes
%       the number of unmeasured disturbances entering the extended system

p=MPCobj.PredictionHorizon;

if narg<2 || isempty(varargin{1})
    Tf=[];
else
    Tf=varargin{1};
end

if narg<3 || isempty(varargin{2}),
    r=MPCstruct.yoff(:)';
    refgiven=0;
else
    refgiven=1;
    r=varargin{2};
end
% Check correctness of reference signal
if ~isa(r,'double'),
    r=zeros(0,ny+1); % to generate an error
elseif any(isinf(r(:))) || ~isreal(r),
    r=zeros(0,ny+1); % to generate an error
end
[n_r,m]=size(r);
if m~=ny,
    ctrlMsgUtils.error('MPC:computation:InvalidSetpointSize','sim',ny);
end

if narg<4,
    v=[];
    SimOptions=[];
elseif narg<5,
    if isa(varargin{3},'mpcsimopt'),
        SimOptions=varargin{3};
        v=[];
    else
        v=varargin{3};
        SimOptions=[];
    end
else
    v=varargin{3};
    SimOptions=varargin{4};
end
if isempty(v),
    v=MPCstruct.voff(:)';
end
if isempty(SimOptions),
    SimOptions=mpcsimopt(MPCobj); % Empty mpcsimopt object
end
% Check correctness of measured disturbance signal
if ~isa(v,'double'),
    v=zeros(0,nv); % to generate an error
elseif any(isinf(v(:))) || ~isreal(v),
    v=zeros(0,nv); % to generate an error
end
[n_v,m]=size(v);
if m~=nv-1,
    ctrlMsgUtils.error('MPC:computation:InvalidMDSize','sim',nv-1);    
end

% remove offsets
r=r-ones(n_r,1)*MPCstruct.yoff(:)';
v=v-ones(n_v,1)*MPCstruct.voff(:)';

% Check correctness of SimOptions and assign defaults
try
    [MPCstruct,params]=mpcsimoptchk(SimOptions,MPCobj);
catch ME
    throw(ME);
end

n_d=params.n_d;
n_ny=params.n_ny;
n_nu=params.n_nu;
n_mv=params.n_mv;
d=params.d;
ynoise=params.ynoise;
unoise=params.unoise;
mv_signal=params.mv_signal;
plantstates=params.plantstates;
diststates=params.diststates;
noisestates=params.noisestates;
simBar=params.simBar;
u0=params.u0;

if refgiven && MPCstruct.openloop,
    if verbose,
        fprintf('-->%s\n',ctrlMsgUtils.message('MPC:computation:OpenLoopIgnoreRef'));    
    end
end

if isempty(Tf),
    Tf=max([n_r,n_v,n_d,n_ny,n_nu,n_mv,p,10]);
else
    if isa(Tf,'double') && numel(Tf)==1 && isfinite(Tf),
        Tf=round(Tf);
    else
        ctrlMsgUtils.error('MPC:computation:InvalidTf','sim');    
    end
end

if n_r>0, r=[r;ones(Tf-n_r,1)*r(n_r,:)]; end;
if n_v>0, v=[v;ones(Tf-n_v,1)*v(n_v,:)]; end;
if n_d>0, d=[d;ones(Tf-n_d,1)*d(n_d,:)];end;
if n_ny>0, ynoise=[ynoise;ones(Tf-n_ny,1)*ynoise(n_ny,:)];end;
if n_nu>0, unoise=[unoise;ones(Tf-n_nu,1)*unoise(n_nu,:)];end;
if n_mv>0, mv_signal=[mv_signal;ones(Tf-n_mv,1)*mv_signal(n_mv,:)];end;

MPCstruct.ref_signal=r';
MPCstruct.md_signal=v';
MPCstruct.ud_signal=d';
MPCstruct.mn_signal=ynoise';
MPCstruct.un_signal=unoise';
MPCstruct.Tf=Tf;
MPCstruct.mv_signal=mv_signal';

if simBar,
    h=waitbar(0,'MPC simulation');
else
    h=-1;
end

MPCstruct.barhandle=h;

try
    [u,y,xp,xmpc]=mpcloop_engine(MPCstruct);
catch ME
    if simBar,
        close(h);
    end
    throw(ME);
end

if simBar,
    close(h);
end

Ts=MPCobj.Ts;

u=u';
y=y';
t=(0:Tf-1)'*Ts;
xp=xp';
xmpc=xmpc';

xmpc=struct('Plant',xmpc(:,plantstates),'Disturbance',xmpc(:,diststates),...
    'Noise',xmpc(:,noisestates),'LastMove',[u0';u(1:end-1,:)]);

if nargout==0,  
    % The number of unmeasured disturbances may be different than nominal
    ndp=MPCstruct.ndp;
    if ndp~=nd,
        % Create a dummy MPC object for plotting
        model=ss(zeros(ny,nu+ndp+nv-1));
        model=setmpcsignals(model,'MV',1:nu,'MD',nu+1:nu+nv-1,'UD',nu+nv:nu+nv-1+ndp);
        model.outputname=MPCobj.Model.Plant.OutputName;
        model.inputname(1:nu)=MPCobj.Model.Plant.InputName(MPCobj.MPCData.mvindex);
        model.inputname(nu+1:nu+nv-1)=MPCobj.Model.Plant.InputName(MPCobj.MPCData.mdindex);
        MPCobj.DisturbanceVariables=MPCobj.DisturbanceVariables(1:nv-1);
        for i=1:ndp,
            umdname=sprintf('UMD%d',i);
            model.inputname{nu+nv-1+i}=umdname;
            MPCobj.DisturbanceVariables(nv-1+i)=struct('Name',umdname,'Units','');
        end
        MPCobj.Model.Plant=model;
    end
    % Add offsets
    r=r(1:Tf,:)+ones(Tf,1)*MPCstruct.yoff(:)';
    v=v(1:Tf,:)+ones(Tf,1)*MPCstruct.voff(:)';
    
    try
        plot(MPCobj,t,y,r,u,v,d);
    catch ME
        throw(ME);
    end
else
    outvec = {y,t,u,xp,xmpc,SimOptions};
    for k=1:nargout
        varargout{k} = outvec{k};
    end
end
