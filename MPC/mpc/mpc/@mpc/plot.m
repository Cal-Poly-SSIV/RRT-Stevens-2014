function [ho, hi] = plot(MPCobj, t, y, r, u, v, d, ho0, hi0, Resp)
% Plot responses generated by MPC simulations.
%
% REQUIRED INPUTS:
% MPCobj   MPC object containing signal type definitions and labels.
% t     Vector of time values, length Nt.
% y     Matrix of output responses, size [Nt, Ny], Ny = number of outputs.
% r     Matrix of setpoints (if closed-loop), same size as y.  If open-loop
%       use r = [];
% u     Matrix of manipulated variable inputs, size [Nt, nu].
% v     Matrix of measured disturbance inputs, size [Nt, nv].
% d     Matrix of unmeasured disturbance inputs, size [Nt, nd].
%
% OPTIONAL INPUTS:
% ho0   Response plot for outputs (class = resppack.timeplot).  Assumed
%       to have been created in a previous call with the same MPCobj.
% hi0   Response plot for inputs (class = resppack.timeplot).  Assumed
%       to have been created in a previous call with the same MPCobj.
% Resp  Response name (string).  If ho0 and hi0 already contain a
%       response with this name, it will be replaced with the new data.
%       Otherwise, the new data will be plotted together with any existing
%       data (for comparisons).
%
% OPTIONAL OUTPUTS:
% ho,hi Response plot objects for possible reuse as ho0, hi0 inputs, or
%       for plot customization.
%
% See also SIM, MPC

%  Author(s):  Larry Ricker and James Owen
%  Copyright 1986-2007 The MathWorks, Inc.
%  $Revision: 1.1.8.14 $ $Date: 2009/11/09 16:28:15 $

%% ------------------------------------------------------------------------
% Error checking
if isempty(MPCobj),
    ctrlMsgUtils.error('MPC:general:EmptyMPCObject','plot');
end

if nargin<2 || ~isvector(t) || ~isnumeric(t) || length(t)<2
    ctrlMsgUtils.error('MPC:computation:InvalidTimeVector','plot');
end

if nargin<3
    ctrlMsgUtils.error('MPC:computation:NoMeasurement','plot');
end

if nargin<4
    ctrlMsgUtils.error('MPC:computation:NoSetpoint','plot');
end

if nargin<5
    ctrlMsgUtils.error('MPC:computation:NoMV','plot');
end

if nargin<6
    v = [];
end
    
if nargin<7
    d = [];
end

%% ------------------------------------------------------------------------
% mpc object
Plant = MPCobj.Model.Plant;
InGrp = Plant.InputGroup;
InName = Plant.InputName;
Nin = length(InName);
Nmv = length(InGrp.Manipulated);
if isfield(InGrp, 'Measured')
    Nmd = length(InGrp.Measured);
else
    Nmd = 0;
end
if isfield(InGrp, 'Unmeasured')
    Nud = length(InGrp.Unmeasured);
else
    Nud = 0;
end
OutName = Plant.OutputName;
Nout = length(OutName);

% time vector
t = t(:);
Nt = length(t);

% measurement
[n, ny] = size(y);
if n ~= Nt || ny ~= Nout
    ctrlMsgUtils.error('MPC:computation:InvalidMeasurementSize2D', n, ny, Nt, Nout);    
end

% reference
if ~isempty(r)
    [n, ny] = size(r);
    if  n ~= Nt || ny ~= Nout
        ctrlMsgUtils.error('MPC:computation:InvalidSetpointSize2D',n, ny, Nt, Nout);            
    end
end

% mv
[n, nu] = size(u);
if n ~= Nt || nu ~= Nmv
    ctrlMsgUtils.error('MPC:computation:InvalidMVSize',n, nu, Nt, Nmv);                
end

% measured disturbance
if isempty(v)
    if Nmd ~= 0
        ctrlMsgUtils.error('MPC:computation:InvalidMDSize',0, 0, Nt, Nmd);                        
    end
else
    [n, nv] = size(v);
    if n ~= Nt || nv ~= Nmd
        ctrlMsgUtils.error('MPC:computation:InvalidMDSize',n, nv, Nt, Nmd);                                
    end
end

% unmeasured disturbance
if isempty(d)
    if Nud ~= 0
        ctrlMsgUtils.error('MPC:computation:InvalidUMDSize',0, 0, Nt, Nud);                        
    end
else
    [n, nd] = size(d);
    if n ~= Nt || nd ~= Nud
        ctrlMsgUtils.error('MPC:computation:InvalidUMDSize', n, nd, Nt, Nud);                                
    end
end

%% ------------------------------------------------------------------------
Prefs = cstprefs.tbxprefs;
Pos = [];
axIn = [];

% Define response plot objects for outputs 
if nargin < 8 || isempty(ho0) || ~ishandle(ho0) || ~isa(ho0, 'mpcobjects.simplot')
    NewOut = true;
    [axIn,axOut] = LocalGetAxes(Prefs);
    for i = 1:Nout
        if isempty(OutName{i})
            OutName{i} = sprintf('Out(%i)', i);
        end
    end
    ho = mpcobjects.simplot(axOut, Nout, 'OutputName', OutName, 'Tag', 'mpc','Type','outputs');
    
    if ~isempty(r)
        ho.setInputWidth(Nout);
        SetpointName = cell(Nout,1);
        for i = 1:Nout
            SetpointName{i} = [OutName{i}, ' Setpoint'];
        end
        ho.Input.ChannelName = SetpointName; 
    end
    ho.Options = struct('SettlingTimeThreshold', Prefs.SettlingTimeThreshold, 'RiseTimeLimits', Prefs.RiseTimeLimits);

    % Delete datatips when the axis is clicked
    set(allaxes(ho),'ButtonDownFcn',{@LocalAxesButtonDownFcn ho});
    % Control cursor and datatip popups over characteristic markers
    % REVISIT: remove this code when MouseEntered/Exited event available
    fig = ho.AxesGrid.Parent;
    if isempty(get(fig,'WindowButtonMotionFcn'))
        set(fig,'WindowButtonMotionFcn',@hoverfig)
    end
    Pos = get(fig, 'Position');
else
    NewOut = false;
    ho = ho0;
end

% Define response plot objects for inputs 
if nargin < 9 || isempty(hi0) || ~ishandle(hi0) || ~isa(hi0, 'mpcobjects.simplot')
    NewIn = true;
    for i = 1:Nin
        if isempty(InName{i})
            InName{i} = sprintf('In(%i)', i);
        end
    end
    
    % If no input axes are created - create them
    if isempty(axIn)
        figure('Visible','off');
        axIn = axes;
        LocalSetAxesPrefs(axIn,Prefs)
    end    
    Opts = struct('SettlingTimeThreshold', Prefs.SettlingTimeThreshold,'RiseTimeLimits', Prefs.RiseTimeLimits);
    hi = mpcobjects.simplot(axIn, Nin, 'OutputName', InName, 'Tag', 'mpc','Type', 'inputs','Options',Opts);
    
    % Delete datatips when the axis is clicked
    set(allaxes(hi),'ButtonDownFcn',{@LocalAxesButtonDownFcn hi})
    % Control cursor and datatip popups over characteristic markers
    % REVISIT: remove this code when MouseEntered/Exited event available
    fig = hi.AxesGrid.Parent;
    if isempty(get(fig,'WindowButtonMotionFcn'))
        set(fig,'WindowButtonMotionFcn',@hoverfig)
    end
    if ~isempty(Pos)
        set(fig, 'Position', [Pos(1)-10, Pos(2)+20, Pos(3) Pos(4)]);
    end
else
    NewIn = false;
    hi = hi0;
end

% Define response names
if nargin < 10
    Resp = localDefaultName(hi,ho);
end

%% ------------------------------------------------------------------------
% Load output data
Duration = [t(1) t(end)];
LocalAddData(ho, t, y, LocalInputCheck(r, t), Resp);

if NewOut
    % Right-click menus
    mo = mpcplotmenu(ho);

    % Add characteristics
    ho.addCharMenu(mo.Characteristics, xlate('Peak Response'),...
        'wavepack.TimePeakAmpData', 'wavepack.TimePeakAmpView',...
        'resppack.SimInputPeakView');

    if ~isempty(r)
        ho.Input.Visible = 'on';
    end
    ho.Visible = 'on';    
end

% Load input data
U = zeros(Nt,Nin); 
iMV = sort(MPCobj.Model.Plant.InputGroup.Manipulated);
U(:, iMV) = LocalInputCheck(u, t); 
InUnits = cell(1,Nin);
for i = 1:length(iMV)
    InUnits{iMV(i)} = MPCobj.ManipulatedVariables(i).Units;
end
if Nmd > 0
    iMD = sort(MPCobj.Model.Plant.InputGroup.Measured);
    U(:, iMD) = LocalInputCheck(v, t);
    for i = 1:length(iMD)
        InUnits{iMD(i)} = MPCobj.DisturbanceVariables(i).Units;
    end
end
if Nud > 0
    iUD = sort(MPCobj.Model.Plant.InputGroup.Unmeasured);
    U(:, iUD) = LocalInputCheck(d, t);
    for i = 1:length(iUD)
        InUnits{iUD(i)} = MPCobj.DisturbanceVariables(i+Nmd).Units;
    end
end
[ts, Us] = stairs(t, U);
LocalAddData(hi, ts(:,1), Us, [], Resp);

if NewIn
    % Right-click menus for input plot
    mi = mpcplotmenu(hi);

    % Add characteristics
    hi.addCharMenu(mi.Characteristics, xlate('Peak Response'),...
        'wavepack.TimePeakAmpData', 'wavepack.TimePeakAmpView',...
        'resppack.SimInputPeakView');
    
    hi.Visible = 'on';
end  
if Duration(2) > Duration(1)
    hi.setfocus(Duration,'sec','Time');
end
A = hi.AxesGrid;
A.YLabel = '';
for i = 1:Nin
    if ~isempty(InUnits{i})
        InName{i} = sprintf('%s, %s', InName{i}, InUnits{i});
    end
end
if Nin == 1
    A.Title = sprintf('Plant Input:  %s', InName{1});
    A.RowLabel = {''};
else
    A.Title = 'Plant Inputs';
    A.RowLabel = InName;
end
hi.draw;
if Duration(2) > Duration(1)
    ho.setfocus(Duration,'sec','Time');
end
A = ho.AxesGrid;
A.YLabel = '';
for i = 1:Nout
    Units = MPCobj.OutputVariables(i).Units;
    if ~isempty(Units)
        OutName{i} = sprintf('%s, %s', OutName{i}, Units);
    end
end
if Nout == 1
    A.Title = sprintf('Plant Output:  %s', OutName{1});
    A.RowLabel = {''};
else
    A.Title = 'Plant Outputs';
    A.RowLabel = OutName;
end
ho.draw;

% Set the appdata so that grouped plots can find eachother
ho.Appdata = struct('inputs',hi);
hi.Appdata = struct('outputs',ho);

set(hi.AxesGrid.Parent,'Visible','on');
set(ho.AxesGrid.Parent,'Visible','on');

% ---------------------------------------------------------------------
% Purpose:  Add data to plot
% ---------------------------------------------------------------------
function R = LocalAddData(h, t, A, Ai, Resp)

% Determine whether or not Resp exists
Rs = h.Responses;
R = [];
for i = 1:length(Rs)
    if strcmp(Rs(i).Name, Resp)
        R = Rs(i);
        break
    end
end

% If a response alrwady exists modify it
if ~isempty(R) && ishandle(R) && ~strcmpi(h.axesgrid.NextPlot,'add')
    set(R.Data,'Amplitude',A,'Time',t);
    %R.Data.setTime(t);
else    
    R = h.plot(t, A);
    R.Name = Resp;
end
    
if ~isempty(Ai)
    setinput(h, t , Ai, 'TimeUnits', 'sec');
end


% ---------------------------------------------------------------------
% Purpose:  Extend or clip an input variable
% ---------------------------------------------------------------------
function NewInput = LocalInputCheck(Input, T)

if isempty(Input)
    NewInput = [];
else
    nT = length(T);
    nI = size(Input, 1);
    if nI < nT
        % Extend
        NewInput = [Input ; ones(nT-nI,1)*Input(end,:)];
    elseif nI == nT
        % Copy
        NewInput = Input;
    else
        % Clip
        NewInput = Input(1:nT,:);
    end
end
        
% ----------------------------------------------------------------------------%
% Purpose: Assign preferences to axes
% ----------------------------------------------------------------------------%
function [axIn,axOut] = LocalGetAxes(Prefs)

% Initialization
axIn = [];
axOut = [];
    
% If the user has selected the input axes but the output axes are needed or
% vice versa, switch to the other
f = get(0,'CurrentFigure');
if isempty(f) || isempty(get(f,'CurrentAxes'))
    % Clean slate
    figure('Visible','off');
    axIn = axes;
    LocalSetAxesPrefs(axIn,Prefs)
    figure('Visible','off');
    axOut = axes;
    LocalSetAxesPrefs(axOut,Prefs)
else
    hOut = gcr;
    if isempty(hOut) || ~isa(hOut,'mpcobjects.simplot') || isempty(hOut.Appdata)
        % Clean slate
        figure('Visible','off');
        axIn = axes;
        LocalSetAxesPrefs(axIn,Prefs)
        figure('Visible','off');
        axOut = axes;
        LocalSetAxesPrefs(axOut,Prefs)
    else 
        if strcmp(hOut.Type,'outputs')
            hIn = hOut.Appdata.inputs;
        else
            hIn = hOut;
            hOut = hIn.Appdata.outputs;     
        end
        % The other plot may be been deleted 
        if ishandle(hOut)
            axOuts = hOut.getaxes;
            axOut = axOuts(1);
        end        
        if ishandle(hIn)
            axIns = hIn.getaxes;
            axIn = axIns(1);
        end     
        % Build new axes to replace deleted ones
        if isempty(axIn)
            figure('Visible','off');
            axIn = axes;
            LocalSetAxesPrefs(axIn,Prefs)
        else
            set(hIn.AxesGrid.Parent,'Visible','off');
        end
        if isempty(axOut)
            figure('Visible','off');
            axOut = axes;
            LocalSetAxesPrefs(axOut,Prefs)
        else
            set(hOut.AxesGrid.Parent,'Visible','off');
        end
    end
end

   
% ----------------------------------------------------------------------------%
% Purpose: Axes callback to delete datatips when clicked
% ----------------------------------------------------------------------------%
function LocalAxesButtonDownFcn(EventSrc,EventData,RespPlot) %#ok<INUSL>
% Axes ButtonDown function
% Process event
switch get(get(EventSrc,'Parent'),'SelectionType')
   case 'normal'
      PropEdit = PropEditor(RespPlot,'current');  % handle of (unique) property editor
      if ~isempty(PropEdit) && PropEdit.isVisible
         % Left-click & property editor open: quick target change
         PropEdit.setTarget(RespPlot);
      end
      % Clear all data tips
      delete(find(handle(EventSrc), 'Tag', 'DataTipMarker'))
   case 'open'
      % Double-click: open editor
      if usejava('MWT')
         PropEdit = PropEditor(RespPlot);
         PropEdit.setTarget(RespPlot);
      end
end

% function localManageHold(ax)
% 
% h = gcr(ax);  % is AX already associated with a response plot?
% NewPlot = strcmp(get(ax,'NextPlot'),'replace');
% 
% if NewPlot
%   % Clear any existing response plot upfront (otherwise style
%   % settings below get erased by CLA in respplot/check_hold)
%   if ~isempty(h)
%     cla(h.AxesGrid,handle(ax))  % speed optimization
%   end
%   
%   % Release manual limits and hide axis for optimal performance
%   % RE: Manual negative Xlim can cause warning for BODE (not reset by clear)
%   set(ax,'Visible','off','XlimMode','auto','YlimMode','auto')
% end
  


function LocalSetAxesPrefs(ax,Prefs)

set(ax,...
   'XGrid',      Prefs.Grid,...
   'YGrid',      Prefs.Grid,...
   'XColor',     Prefs.AxesForegroundColor,...
   'YColor',     Prefs.AxesForegroundColor,...
   'FontSize',   Prefs.AxesFontSize,...
   'FontWeight', Prefs.AxesFontWeight,...
   'FontAngle',  Prefs.AxesFontAngle,...
   'Selected',   'off')
set(get(ax,'Title'),...
   'FontSize',  Prefs.TitleFontSize,...
   'FontWeight',Prefs.TitleFontWeight,...
   'FontAngle', Prefs.TitleFontAngle)
set(get(ax,'Title'),...
   'FontSize',  Prefs.TitleFontSize,...
   'FontWeight',Prefs.TitleFontWeight,...
   'FontAngle', Prefs.TitleFontAngle)
set([get(ax,'XLabel'),get(ax,'YLabel')],...
   'Color',[0 0 0],...
   'FontSize',  Prefs.XYLabelsFontSize,...
   'FontWeight',Prefs.XYLabelsFontWeight,...
   'FontAngle', Prefs.XYLabelsFontAngle)


function newName = localDefaultName(hi,ho)

currentNames = [get(hi.Responses,{'Name'}) get(ho.Responses,{'Name'})];
currentNames = [currentNames{:}];
n = 1;
while ~isempty(strfind(currentNames,sprintf('MPC response%d',n)))
      n = n+1;
end
newName = sprintf('MPC response%d',n);
